```eval_rst

.. toctree::
   :maxdepth: 1
   :caption: راهنما
   :hidden:

   manual/getting-started
   manual/variables
   manual/integers-and-floating-point-numbers
   manual/mathematical-operations
   manual/complex-and-rational-numbers
   manual/strings
   manual/functions
   manual/control-flow
   manual/variables-and-scoping
   manual/types
   manual/methods
   manual/constructors
   manual/conversion-and-promotion
   manual/interfaces
   manual/modules
   manual/documentation
   manual/metaprogramming
   manual/arrays
   manual/missing
   manual/networking-and-streams
   manual/parallel-computing
   manual/asynchronous-programming
   manual/multi-threading
   manual/distributed-computing
   manual/running-external-programs
   manual/calling-c-and-fortran-code
   manual/handling-operating-system-variation
   manual/environment-variables
   manual/embedding
   manual/code-loading
   manual/profile
   manual/stacktraces
   manual/performance-tips
   manual/workflow-tips
   manual/style-guide
   manual/faq
   manual/noteworthy-differences
   manual/unicode-input
   manual/command-line-options
```
# مستندات جولیا 1.6

به مستندات جولیا 1.6 خوش آمدید.

## مقدمه

محاسبات علمی از گذشته نیاز به بیشترین کارایی داشتند، با این وجود متخصصان این زمینه عمدتا به سمت استفاده از زبان‌های کندتر پویا برای کارهای روزمره حرکت کرده‌اند.
ما معتقدیم دلایل خوب زیادی برای ترجیح زبان‌های پویا برای این کاربردها وجود دارد و انتظار نداریم که کاربرد آنها کم شود.
خوشبختانه، طراحی زبان مدرن و تکنیک‌های کامپایلر این امکان را فراهم می‌کند که تقریبا مبادله کارایی برای پویایی را از بین ببریم و یک محیط یکپارچه به اندازه کافی توانا برای ‌نمونه‌سازی و به اندازه کافی کارآمد برای استقرار برنامه‌هایی که نیازمند کارایی بالا هستند، فراهم کنیم. زبان برنامه نویسی جولیا این خواسته‌ها را برآورده می‌کند: یک زبان پویای انعطاف‌پذیر، مناسب برای محاسبات علمی و عددی، با عملکردی قابل مقایسه با زبان‌های سنتی غیر پویا است.

از آنجا که کامپایلر جولیا با مفسران مورد استفاده برای زبان‌هایی مانند Python یا R متفاوت است، ممکن است در ابتدا کارایی جولیا برای‌تان غیرمشهود باشد. اگر‌ احساس کردید سرعت اجرای برنامه‌ای که نوشتید کند است، توصیه می‌کنیم قبل از هر چیز دیگری، قسمت 
[نکات عملکرد](manual/performance-tips.html)
 را مطالعه کنید. زمانی که نحوه کار جولیا را درک کنید، نوشتن کدی که تقریباً سرعتی برابر C داشته باشد، آسان است.

جولیا دارای امکان تخصیص اختیاری نوع به متغیرها، ارسال چندتایی و کارایی خوب است که با استفاده از استنباط نوع(type inference)
و [کامپایل در لحظه (JIT)](https://en.wikipedia.org/wiki/Just-in-time_compilation)‌ به دست آمده و با استفاده از [LLVM](https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine) پیاده‌سازی شده‌است. جولیا چندین پارادایم را پشتیبانی می‌کند که باعث به دست آوردن ترکیبی از امکانات برنامه‌نویسی دستوری، تابعی و شی‌گرا می‌شود. جولیا سهولت و رسایی را برای محاسبات عددی سطح بالا، به همان روشی که زبان‌هایی مانند R، MATLAB و Python فراهم می‌کنند، فراهم می‌کند؛ اما از برنامه نویسی عمومی نیز پشتیبانی می‌کند. برای فراهم شدن این مهم، جولیا از اساس زبان‌های برنامه‌نویسی ریاضی‌محور پیروی می‌کند اما از زبان‌های پویای معروف از جمله [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)), [Perl](https://en.wikipedia.org/wiki/Perl_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language)) و [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)) نیز کمک می‌گیرد.

مهمترین عوامل جداکننده جولیا از زبان‌های پویا معمولی عبارتند از:

  * از آنجا که توابع پایه، کتاب‌خانه‌های استاندارد و حتی اعمال مقدماتی مانند محاسبات عددی صحیح به زبان خود جولیا نوشته شده‌اند، زبان اصلی تحمیل و تاثیرگذاری کمی دارد. 
  * یک زبان غنی از نوع‌های قابل استفاده برای ساخت و توصیف اشیا، که می‌توانند به صورت اختیاری برای تعریف نوع‌های دیگر نیز استفاده شوند
  * توانایی تعریف رفتار تابع در هنگام دریافت ترکیبات متفاوتی از آرگومان‌ها با استفاده از [ارسال چندتایی](https://en.wikipedia.org/wiki/Multiple_dispatch)
  * تولید خودکار کد کارآمد و تخصصی برای انواع مختلف آرگومان‌ها
  * کارایی خوب، در حد نزدیک به کدهای کامپایل‌شده به صورت ایستا مانند C

اگرچه گاهی اوقات از زبان‌های پویا به‌عنوان "بی نوع" نیز یاد می‌شود، اما لزوما اینگونه نیستند: هر شی، چه مقدماتی و چه تعریف شده توسط کاربر، دارای نوعی است. فقدان مشخص کردن نوع در بیشتر زبان‌های پویا به این معناست که شخص نمی‌تواند درمورد نوع مقادیر به کامپایلر دستور دهد و غالباً به طور صریح نمی‌توان در مورد نوع صحبت کرد. از طرف دیگر، در زبان‌های ایستا، اگرچه می‌توان - و معمولاً باید - نوع مقادیر را برای کامپایلر شرح داد، اما نوع فقط در زمان کامپایل وجود دارد و نمی‌توان آنها را در زمان اجرا دستکاری یا مشخص کرد. در جولیا، نوع‌ها خود اشیایی در زمان اجرا هستند و همچنین می‌توانند برای انتقال اطلاعات به کامپایلر مورد استفاده قرار گیرند.

در حالی که برنامه نویس معمولی نیازی به استفاده صریح از نوع یا اعزام چندگانه ندارد، آنها ویژگی‌های اصلی یک‌پارچه‌کننده جولیا هستند: توابع با ترکیبات مختلفی از انواع آرگومان‌های ورودی تعریف می‌شوند و با ارسال به منطبق‌ترین تعریف اعمال می‌شوند. این مدل برای برنامه‌نویسی ریاضی مناسب است، زیرا برخلاف اعزام شی‌گرا در آن طبیعی نیست آرگومان ورودی اول مشخص کننده یک عملگر باشد. عملگرها تنها توابعی با علامت‌گذاری خاص هستند. برای مثال برای توسعه عملگر جمع برای انواع داده‌های جدید تعریف شده توسط کاربر، می‌توانید تعریف‌های جدیدی برای تابع `+` تعریف کنید. سپس کد موجود به طور یکپارچه برای انواع داده‌های جدید اعمال می‌شود.

 بازده محاسباتی جولیا به دلیل تشخیص نوع در زمان اجرا (که با نشانه‌گذاری اختیاری ممکن شده‌است)، و تمرکز بالا بر کارایی از ابتدای پروژه، بیش از سایر زبان‌های پویا و حتی بعضی زبان‌های ایستا است. برای مسائل عددی در مقیاس بزرگ، سرعت همیشه مهم بوده و هست، و احتمالاً همیشه نیز مهم خواهد بود. اندازه داده‌های پردازش‌شده در دهه‌های گذشته همواره با قانون مور همگام بوده‌است.

جولیا قصد دارد ترکیبی بی‌سابقه از سهولت استفاده، قدرت و کارایی را در یک زبان واحد ایجاد کند. علاوه بر موارد ذکر شده، برخی از مزایای جولیا نسبت به سیستم‌های دیگر عبارتند از:

  * رایگان و کد باز ([MIT licensed](https://github.com/JuliaLang/julia/blob/master/LICENSE.md))
  * انواع داده تعریف شده توسط کاربر به اندازه دیگر انواع سریع و فشرده هستند.
  * نیازی به vectorize کردن کد برای بهبود کارایی نیست.
  * برای برنامه‌نویسی موازی و توزیع‌شده طراحی شده‌است.
  * چندنخی‌سازی سبک سبز ([کوروتین](https://en.wikipedia.org/wiki/Coroutine))
  * سیستم نوع‌گذاری نامشهود اما پرقدرت
  * تبدیلات و گسترش ظریف و منعطف برای انواع عددی و انواع دیگر
  * پشتیبانی کارآمد از [Unicode](https://en.wikipedia.org/wiki/Unicode)، از جمله [UTF-8](https://en.wikipedia.org/wiki/UTF-8)
  * امکان فراخوانی توابع `C` به صورت مستقیم (بدون wrapper یا `API`)
  * قابلیت‌های قدرمتند برای مدیریت دیگر پردازه‌ها
  * وجود ماکروهای مانند ماکروهای موجود در `Lisp` و سایر امکانات فرابرنامه‌نویسی
