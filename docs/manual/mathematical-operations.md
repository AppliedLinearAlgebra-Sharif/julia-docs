# عملیات ریاضی و توابع اولیه

زبان برنامه نویسی جولیا یک مجموعه کامل از عملگرهای محاسباتی و بیتی اولیه برای کار بر روی انواع تایپ‌های عددی اولیه را فراهم نموده است. همچنین پیاده‌سازی‌های بهینه از یک مجموعه همه جانبه از توابع استاندارد ریاضی ارائه می‌دهد.

## عملگرهای محاسباتی

[عملگرهای محاسباتی](https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations) زیر برای تمامی تایپ‌های عددی اولیه پشتیبانی می‌شوند:

| نماد | نام           | توضیحات                            |
|:---------- |:-------------- |:-------------------------------------- |
| `+x`       | جمع یگانی     |  عمل همانی                |
| `-x`       | تفریق یگانی    | مقادیر را به وارون جمعی‌شان تبدیل می‌کند |
| `x + y`    | جمع باینری     | عمل جمع                      |
| `x - y`    | تفریق باینری   | عمل تفریق                   |
| `x * y`    | ضرب          | عمل ضرب                |
| `x / y`    | تقسیم         | عمل تقسیم                      |
| `x ÷ y`    | تقسیم صحیح | قسمت صحیح `x / y` را بر می‌گرداند         |
| `x \ y`    | تقسیم بالعکس | معادل با `x / y` است                  |
| `x ^ y`    | توان          | `x` را به توان `y` می‌رساند   |
| `x % y`    | باقیمانده      | معادل با `rem(x,y)` است      |

یک لیترال عددی که دقیقا قبل از یک متغیر یا پرانتز قرار گرفته است، برای مثال در `2x`  یا  `2(x+y)`، به صورت عمل ضرب در نظر گرفته می‌شود، که اولویت بالاتری نسبت به سایر عملیات‌های باینری دارد. 

سیستم ارتقاء جولیا به صورت طبیعی و خود به خودی(اتوماتیک) عملگرهای محاسباتی را برای مخلوطی از انواع تایپ‌ها مدیریت کرده و به درستی کار می‌کنند. برای اطلاع بیشتر در مورد سیستم ارتقاء، بخش [تبدیل و ارتقاء](@ref conversion-and-promotion) را ببیند.

چند مثال ساده را در زیر مشاهده می‌کنید:

```julia
julia> 1 + 2 + 3
6

julia> 1 - 2
-1

julia> 3*2/12
0.5
```


(طبق قرار داد، برای استحکام بیشتر در بیان عملگرها، ما آن‌ها را در نزدیکترین حالت به عملوندشان، قبل از عملوند قرار می‌دهیم. برای مثال، ما معمولاً باید بنویسیم `x+2-`تا ابتدا مقدار `x` را منفی کرده و سپس `2` را به آن اضافه کنیم.)

در عمل ضرب، `false` به صورت یک *صفر قوی* عمل می‌کند.

```julia
julia> NaN * false
0.0

julia> false * Inf
0.0
```

این کار برای پیشگیری از انتشار مقادیر  `NaN` در کمیت‌هایی که می‌دانیم برابر صفر هستند، استفاده می‌شود. برای اطلاعات بیشتر [Knuth (1992)](https://arxiv.org/abs/math/9205211) را ببینید.


## عملگرهای بولی

[عملگر‌های بولی](https://en.wikipedia.org/wiki/Boolean_algebra#Operations) زیر روی تایپ `Bool`  اعمال می شوند:

| نماد | توضیحات                                                    |
|:---------- |:--------------------------------------------------------|
|     `!x`  |            منفی کردن                                  |
| `x && y`   | [و اتصال کوتاه](@ref man-conditional-evaluation) |
| `x \|\| y` | [یا اتصال کوتاه](@ref man-conditional-evaluation)  |

عمل منفی کردن `true` را به `false` تبدیل می‌کند و برعکس. عملیات‌های اتصال کوتاه در صفحه‌ی لینک‌شده توضیح داده شده‌اند.

توجه کنید که  `Bool` یک تایپ عدد صحیح است و همه‌ روابط ارتقا و عملگر‌های عددی روی آن تعریف می‌شوند.


## عملگر‌های بیتی

[عملگرهای محاسباتی](https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators) زیر برای تمامی تایپ‌های صحیح اولیه پشتیبانی می‌شوند:

| توضیحات | نماد                                                                     |
|:---------- |:------------------------------------------------------------------------ |
| `~x`       | عمل not به صورت بیت به بیت                                                              |
| `x & y`    | عمل and به صورت بیتی                                                              |
| `x \| y`   | عمل or به صورت بیتی                                                               |
| `x ⊻ y`    | عمل xor بیتی                                               |
| `x >>> y`  | [شیفت منطقی](https://en.wikipedia.org/wiki/Logical_shift) به سمت راست       |
| `x >> y`   | [شیفت محاسباتی](https://en.wikipedia.org/wiki/Arithmetic_shift) به سمت راست |
| `x << y`   | شیفت منطقی/محاسباتی به سمت چپ                                      |

مثال‌هایی از عملگرهای بیتی در جولیا:

```julia
julia> ~123
-124

julia> 123 & 234
106

julia> 123 | 234
251

julia> 123 ⊻ 234
145

julia> xor(123, 234)
145

julia> ~UInt32(123)
0xffffff84

julia> ~UInt8(123)
0x84
```


## عملگرهای بروزرسان

تمام عملگرهای باینری محاسباتی و بیتی یک حالت بروز رسانی دارند که نتایج عملیات را در عملوند سمت چپ خود می‌ریزند. حالت بروزرسانی عملگرهای باینری به وسیله استفاده بدون واسطه از `=` پس از عملگر، به کار گرفته می‌شود. برای نمونه، نوشتن `x+=3` معادل است با نوشتن `x=x+3`:

```julia
julia> x = 1
1

julia> x += 3
4

julia> x
4
```


حالت بروزرسانی تمام عملگرهای محاسباتی و بیتی به صورت زیر هستند:

```
+=  -=  *=  /=  \=  ÷=  %=  ^=  &=  |=  ⊻=  >>>=  >>=  <<=
```

```eval_rst

.. note::

    An updating operator rebinds the variable on the left-hand side. As a result, the type of the
    variable may change.

    .. code-block:: julia

        julia> x = 0x01; typeof(x)
        UInt8

        julia> x *= 2 # Same as x = x * 2
        2

        julia> typeof(x)
        Int64

```

## عملگرهای نقطه‌ای برداری

برای تمامی عملیات‌های باینری مانند `^`، یک عملیات متناظر نقطه‌ای `^.` وجود دارد که به صورت خود به خودی(اتوماتیک) عمل `^` را بر روی تک تک المان‌های یک آرایه اعمال می‌کند. برای مثال، عبارت `3^[1,2,3]` تعریف نشده است زیرا مکعب یک ارایه‌ (ارایه غیر مربعی) تعریف استاندارد ریاضیاتی ندارد. اما `3^.[1,2,3]` به صورت محاسبه‌ی المانی(یا برداری) `[3^3, 3^2, 3^1]` تعریف شده است. به طور مشابه برای عملگرهای یگانی مانند `!` یا `√` نیز  `√.` وجود دارد که عملیات را به صورت المانی اجرا می‌کند.

```julia
julia> [1,2,3] .^ 3
3-element Vector{Int64}:
  1
  8
 27
```


به طور دقیق‌تر، `a.^b`(این عبارت یعنی تک تک المان‌های آرایه `a` به توان المان متناظر آن در آرایه `b` برسد. یعنی المان اول `a` به توان المان اول `b` و المان دوم `a` به توان المان دوم `b` و…) به صورت [فراخوانی نقطه‌ای](@ref man-vectorized)
 `(a,b).(^)` شناخته می‌شود که یک عملیات [گسترش](@ref Broadcasting) را اجرا می‌کند: این عملیات می‌تواند میان آرایه‌ها و اسکالرها، آرایه‌های هم اندازه (انجام عملیات به صورت المانی) و  حتی میان آرایه‌هایی با اشکال مختلف(مثلاً ترکیب بردار‌های ستونی و ردیفی برای ساخت ماتریس) اعمال شود. علاوه بر این، مانند تمام فراخوانی‌های نقطه‌ای برداری(المانی)، این عملگرهای نقطه‌ای نیز همپوش هستند. برای مثال، اگر شما `2 .* A.^2 .+ sin.(A)` (که معادل با `@. 2A^2 + sin(A)` است و ماکروی [`.@`](@ref @__dot__) macro) در آن استفاده شده است) را برای آرایه‌ای مانند `A` محاسبه کنید، یک تک حلقه روی `A` اجرا می‌شود که `2a^2 + sin(a)` را برای هر المان از `A` محاسبه می‌کند. به طور خاص، فراخوانی نقطه‌ای تودرتو مانند `f.(g.(x))` همپوشانی شده‌ است و این یعنی عملگرهای باینری مجاور مانند `x.+ 3.*x.^2` با فراخوانی نقطه‌ای تودرتوی `(+).(x, (*).(3, (^).(x, 2)))` معادل هستند.

علاوه بر این‌ موارد، عملگرهای بروز‌رسان نقطه‌ای مانند `a.+=b` (یا `a+=b.@`) به صورت `a.=a.+b` اجرا می‌شوند، که در آن `=.` یک عملیات تخصیص در محل همپوشانی شده است (نوشته [نحو نقطه‌ای]((@ref man-vectorized)) را ببینید).

دقت کنید که نحو(سینتکس) نقطه‌ای برای عملگرهای تعریف شده توسط کاربر نیز قابل استفاده است. برای مثال اگر شما `⊗(A,B) = kron(A,B)` را به منظور عمل  `A ⊗ B` برای داشتن یک سینتکس راحت برای ضرب کرونر تعریف کنید، پس از آن بدون هیچ کد اضافه‌ای شما می‌توانید `[C,D]⊗.[A,B]` را برای محاسبه `[A⊗C,B⊗D]` بیان کنید. 

ترکیب عملگرهای نقطه‌ای با لیترال‌های عددی می‌تواند ابهام آور باشد. به طور مثال، معلوم نیست که منظور از عبارت `1.+x` به صورت `1. + x` است یا `1 .+ x`. در نتیجه این نوع نحوه بیان مجاز نیست و حتماً باید به وسیله فضای خالی میان عملگر نقطه و عملوندهایش در چنین مواردی فاصله ایجاد کنید.

## مقایسات عددی

عملگرهای مقایسه‌ای استاندارد برای تمام تایپ‌های عددی اولیه تعریف شده‌اند:

| عملگر                     | تووضیحات                     |
|:---------------------------- |:------------------------ |
| `==`                 | برابری                 |
| `!=`, [`≠`](@ref !=) | نابرابری               |
| `<`                  | کوچکتر                 |
| `<=`, [`≤`](@ref <=) | کوچتر یا مساوی    |
| `>`                  | بزرگتر              |
| `>=`, [`≥`](@ref >=) | بزرگتر یا مساوی |

در اینجا چند مثال ساده را مشاهده می‌کنید:

```julia
julia> 1 == 1
true

julia> 1 == 2
false

julia> 1 != 2
true

julia> 1 == 1.0
true

julia> 1 < 2
true

julia> 1.0 > 3
false

julia> 1 >= 1.0
true

julia> -1 <= 1
true

julia> -1 <= -1
true

julia> -1 <= -2
false

julia> 3 < -0.5
false
```


اعداد صحیح به صورت استاندارد با مقایسه‌ی بیت‌ها مورد سنجش قرار داده می‌شوند. اعداد اعشاری نیز با توجه به [استاندارد IEEE 754](https://en.wikipedia.org/wiki/IEEE_754-2008) مقایسه می شوند:

+ ترتیب اعداد متناهی، به همان صورت معمول است.
+ صفر مثبت برابر است با صفر منفی اما از آن بزرگتر نیست.
+ `Inf` با خودش برابر و از هر چیز دیگری بجز  `NaN` بزرگتر است.
+ `Inf` با خودش برابر و از هر چیز دیگری بجز `NaN` کوچکتر است.
+ `NaN` نه با چیزی برابر، نه از چیزی بزرگتر و نه کوچکتر است. این گزاره شامل خودش هم می‌شود.

نکته آخر بسیار شگفت انگیز است و ارزش دقت دارد:

```julia
julia> NaN == NaN
false

julia> NaN != NaN
true

julia> NaN < NaN
false

julia> NaN > NaN
false
```


این نکته در کار با [آرایه‌ها](@ref man-multi-dim-arrays) می‌تواند موجب کمی سردرد شود:

```julia
julia> [1 NaN] == [1 NaN]
false
```


جولیا توابعی اضافی برای آزمون اعداد در مقادیر خاص فراهم کرده است که می‌تواند در موقعیت‌هایی مانند مقایسه‌‌های کلید هش استفاده شود:

| تابع                | تست می‌کند که                  |
|:----------------------- |:------------------------- |
| `isequal(x, y)` | آیا `x` و `x` یکسان هستند؟ |
| `isfinite(x)`   | آیا `x` یک عدد متناهی است؟    |
| `isinf(x)`      | آیا `x` بی‌نهایت است؟           |
| `isnan(x)`      | آیا `x` یک عدد نیست؟       |

`isequal` متغیر `NaN` را برابر با خودش در نظر می‌گیرد:

```julia
julia> isequal(NaN, NaN)
true

julia> isequal([1 NaN], [1 NaN])
true

julia> isequal(NaN, NaN32)
true
```


`isequal` همچنین می‌تواند برای تمییز دادن صفرهای علامت‌دار استفاده شود:

```julia
julia> -0.0 == 0.0
true

julia> isequal(-0.0, 0.0)
false
```


مقایسات ترکیبی میان اعداد صحیح علامت‌دار، اعداد صحیح بدون علامت و اعداد اعشاری می‌تواند گول زننده باشد. مراقبت‌های زیادی انجام شده است تا اطمینان حاصل شود که جولیا آن‌ها را به درستی انجام می‌دهد.

برای بقیه تایپ‌ها، `isequal` به صورت پیشفرض `==` را صدا می‌زند؛ بنابراین اگر شما می‌خواهید برابری برای تایپ‌های خود را بسنجید، کافیست از متد `==` استفاده کنید. اگر شما می‌خواهید تابع سنجش برابری خودتان را تعریف کنید، بهتر است یک تابع `hash` متناظر تعریف کنید تا اطمینان حاصل شود که `(isequal(x,y` برابری `(hash(x)==hash(y` را می‌رساند.

### مقایسه‌های زنجیره‌ای

بر خلاف بسیاری از زبان ها [به استثنای پایتون](https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators)، مقایسه‌ها می‌توانند به طور دلخواه به صورت زنجیره‌ای استفاده شوند:

```julia
julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
true
```


استفاده از مقایسه‌های زنجیره‌ای در کدهای عددی، اغلب باعث راحتی بسیاری می‌شود. این مقایسه‌ها از عملگر `&&` برای سنجش‌های اسکالر و از عملگر `&` برای سنجش‌های المانی استفاده می‌کنند که این کار اجازه می‌دهد تا بر روی آرایه‌ها نیز عمل کنند. برای مثال عبارت  `0 .< A .< 1` یک ارایه بولی نتیجه می‌دهد که درایه‌هایی که true هستند، نشان می‌دهند که درایه‌‌های متناظر آن در `A` بین صفر و یک هستند.

به نحوه‌ی رفتار ارزیابی در مقایسه‌های زنجیره‌ای توجه داشته باشید:

```julia
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> v(1) < v(2) <= v(3)
2
1
3
true

julia> v(1) > v(2) <= v(3)
2
1
false
```


عبارتی که در وسط آمده است فقط یک بار ارزیابی می‌شود، و اگر عبارت به صورت  `v(1) < v(2) && v(2) <= v(3)` نوشته شده‌بود، دوبار ارزیابی می‌شد. با این حال، ترتیب ارزیابی‌ها در یک مقایسه زنجیره‌ای تعریف نشده است. به شدت توصیه می‌شود که از عباراتی با عوارض جانبی (مانند چاپ) در مقایسه‌های زنجیره‌ای بپرهیزید. اگر به عباراتی برای عوارض جانبی نیاز داشتید، از عملگر `&&` اتصال-کوتاه به طور صریح استفاده کنید (نوشته ارزیابی اتصال-کوتاه را ببینید).

### توابع ابتدایی

جولیا یک مجموعه‌ی جامع از توابع و عملگر‌های ریاضی را فراهم کرده است. این عملگرهای ریاضی به عنوان یک کلاس گسترده از مقادیر عددی به عنوان تعاریف منطقی اولیه تعریف شده و اعداد صحیح، اعشاری، حقیقی و مختلط را، هر کجایی که این تعاریف معنی داشته باشند، ارائه می‌دهد.

علاوه بر این، این توابع(مانند هر تابع دیگر جولیا) می‌توانند با استفاده از [نحو(سینتکس) نقطه‌ای](@ref man-vectorized) 
`f.(A)` به صورت برداری(المانی) بر روی آرایه‌ها و دیگر مجموعه‌ها اعمال شوند. برای مثال `sin.(A)`، تابع سینوس را بر روی تمام المان‌های آرایه‌ی `A` اعمال می‌کند.

## تقدم و شرکت‌پذیری عملگرها

جولیا شرکت پذیری و ترتیب عملگرها را به صورت زیر اعمال می‌کند. ترتیب جدول زیر از بیشترین تقدم‌ به کمترین تقدم‌ است:

| دسته       | عملگر                                                                                         | شرکت‌پذیری              |
|:-------------- |:------------------------------------------------------------------------------------------------- |:-------------------------- |
| نحو(سینتکس)         | `.` followed by `::`                                         | چپ                |
| توان | `^`                                                                                               | راست                      |
| یگانی          | `+ - √`                                                                                           | راست[^1]                  |
| بیت شیفت‌ها      | `<< >> >>>`                                                                                       | چپ                       |
| کسر‌ها      | `//`                                                                                              | چپ                       |
| ضرب | `* / % & \ ÷`                                                                                     | چپ[^2]                   |
| جمع       | `+ - \| ⊻`                                                                                        | چپ[^2]                   |
| نحو         | `: ..`                                                                                            | چپ                       |
| نحو         | `\|>`                                                                                             | چپ                       |
| نحو         | `<\|`                                                                                             | راست                      |
| مقایسه‌ها    | `> < >= <= == === != !== <:`                                                                      | بدون شرکت‌پذیری            |
| کنترل روند   | `&&` followed by `\|\|` followed by `?`                                                      | راست                      |
| جفت کردن           | `=>`                                                                                              | راست                      |
| تخصیص‌ها    | `= += -= *= /= //= \= ^= ÷= %= \|= &= ⊻= <<= >>= >>>=`                                            | راست                      |

[^1]:
    عملگرهای یگانی `+` و `-` باید به وسیله‌ پرانتز اطراف آرگومانشان مطرح شوند تا از بی‌مفهومی عملگر `++` و… دور شوند. ترکیب‌های دیگر عملگرهای یگانی به وسیله شرکت‌پذیری راست جدا می‌شوند. برای مثال، `a√√-` به این شکل `((a)√)√-` اعمال می‌شود.
[^2]:
    عملگرهای `+`، `++` و `*` بدون شرکت‌پذیری هستند. `a + b + c` به صورت `(a,b,c)+` اعمال می‌شود و نه `((a,b)+,c)+`. با این حال، روش‌های بازگشت برای `(...a,b,c,d)+` و `(...a,b,c,d)*` به صورت پیش‌فرض با شرکت‌پذیری چپ ارزیابی می‌شود.

برای اطلاع از تمامی تقدمات عملگرهای جولیا، ابتدای فایل [`src/julia-parser.scm`](https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm) را ببینید. توجه کنید که برخی عملگر‌ها ممکن است در ماژول `Base` تعریف نشده باشند، اما در کتابخانه‌های استاندارد، پکیج‌ها یا کد کاربر تعریف شده باشند.

شما همچنین می توانید تقدم به صورت عددی برای هر عملگر داده شده را از طریق تابع پیش ساخته‌ `Base.operator_precedence` پیدا کنید؛ اعداد بالاتر دارای تقدم بالاتری هستند:

```julia
julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 12, 17)

julia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(0, 1, 1)
```


نماد بیان‌کننده شرکت‌پذیری عملگر را نیز می‌توانید به وسیله فراخوانی تابع پیش ساخته `Base.operator_associativity` بیابید:

```julia
julia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)
```


دقت کنید که نماد‌هایی همچون `sin:` تقدم `0` را برمی‌گردانند. این مقدار نشان می‌دهد که عملگرها بی‌اعتبار هستند و منظور از آن عملگرهای با کمترین میزان تقدم نیست. به همین ترتیب، برای چنین عملگرهایی شرکت پذیری آن‌ها `none:` اختصاص داده می‌شود.

[ضرایب لیترال عددی](@ref man-numeric-literal-coefficients)، مثلا `2x`، همانند عمل ضرب دارای بالاترین میزان تقدم نسبت به سایر عملگر‌های باینری هستند، به استثنای عملگر `^`  که به عنوان عمل به توان‌رسانی بالاترین تقدم را دارد.

```julia
julia> x = 3; 2x^2
18

julia> x = 3; 2^2x
64
```


قرار گرفتن در کنار هم مانند یک عملگر یگانی تجزیه می شود، که دارای همان عدم تقارن طبیعی در مجاورت توان است:`-x^y`  و`2x^y`  به ترتیب به صورت `-(x^y)`  و `2(x^y)` اعمال می‌شوند، در حالی که  `x^-y` و `x^2y` به صورت`x^(-y)` و `x^(2y)` اعمال می‌شوند.

## تبدیل‌های عددی

زبان برنامه نویسی جولیا از تبدیلات عددی به سه شکل پشتیبانی می‌کند که تفاوت این شکل‌ها در صحت دقت تبدیل‌هایشان است.

+ نماد `T(x)`  یا `convert(T,x)` ، درواقع `x` را به مقداری با تایپ `T` تبدیل می‌کند.
+ اگر `T` یک تایپ اعشاری باشد، نتیجه نزدیکترین مقدار قابل ارائه است، که می‌تواند مثبت یا منفی بی‌نهایت باشد.
+ اگر `T` یک تایپ صحیح باشد، در صورتی که `x` به وسیله `T` قابل نماایش نباشد، یک `InexactError` به وجود می‌آید .
+ `x % T` یک عدد صحیح `x` را به یک مقدار با تایپ صحیح `T` تبدیل می‌کند، به صورتی که این مقدار برابر با `x` به پیمانه `2^n` است، که در آن `n` تعداد بیت‌ها در `T` است. به عبارت دیگر، نمایش باینری کوتاه شده است تا سازگاری ایجاد شود.
+ تابع گرد کردن، می‌تواند یک تایپ `T` را به صورت اختیاری به عنوان یک آرگومان بگیرد. مثلاً، `round(Int,x)`  کوتاه شده‌ی عبارت `Int(round(x))`  است.


مثال زیر تفاوت این شکل‌ها را روشن می‌سازد:

```julia
julia> Int8(127)
127

julia> Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia> Int8(127.0)
127

julia> Int8(3.14)
ERROR: InexactError: Int8(3.14)
Stacktrace:
[...]

julia> Int8(128.0)
ERROR: InexactError: Int8(128.0)
Stacktrace:
[...]

julia> 127 % Int8
127

julia> 128 % Int8
-128

julia> round(Int8,127.4)
127

julia> round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]
```


[نوشته تغییر و ترویج](@ref conversion-and-promotion) را برای چگونگی تعریف تغییرات و ترویج‌های خود ببینید.

### توابع گرد کننده

| تابع              | توضیحات                      | تایپ بازگشتی |
|:--------------------- |:-------------------------------- |:----------- |
| `round(x)`    | مقدار `x` را به نزدیک‌ترین عدد صحیح گرد می‌کند |  `typeof(x)` |
| `round(T, x)` | مقدار `x` را به نزدیک‌ترین عدد صحیح گرد می‌کند | `T`         |
| `floor(x)`    | مقدار `x` را به سمت `-Inf` گرد می‌کند         | `typeof(x)` |
| `floor(T, x)` | مقدار `x` را به سمت `-Inf` گرد می‌کند         | `T`         |
| `ceil(x)`     | مقدار `x` را به سمت `+Inf` گرد می‌کند         | `typeof(x)` |
| `ceil(T, x)`  | مقدار `x` را به سمت `+Inf` گرد می‌کند         | `T`         |
| `trunc(x)`    | مقدار `x` را به سمت صفر گرد می‌کند           | `typeof(x)` |
| `trunc(T, x)` | مقدار `x` را به سمت صفر گرد می‌کند           | `T`         |

### توابع تقسیم

| تابع                  | توضیحات                                           |
|:------------------------- |:--------------------------------------------------------------------------------------------------------- |
| `div(x,y)`, `x÷y` | تقسیم truncated؛ خارج قسمت را به سمت `0` گرد می‌کند                                                  |
| `fld(x,y)`        | تقسیم floored؛ خارج قسمت را به سمت `Inf-` گرد می‌کند                                                         |
| `cld(x,y)`        | تقسیم ceiling؛ خارج قسمت را به سمت `Inf+` گرد می‌کند                                                         |
| `rem(x,y)`        | باقی‌مانده؛ در شرط `x == div(x,y)*y + rem(x,y)`صدق می‌کند; علامت آن با `x` یکسان است |
| `mod(x,y)`        | حساب پیمانه‌ای(modulus) ؛ در شرط `x == fld(x,y)*y + mod(x,y)` صدق می‌کند ; علامت آن با `y` یکسان است |
| `mod1(x,y)`       |مقدار `mod` با وزن متعادل کننده 1؛ در صورتی که 
`mod(r, y) == mod(x, y)` باشد، `[r∈(0,y` را برای `y>0` یا `(r∈[y,0` را برای `y<0` باز می‌گرداند.   |
| `mod2pi(x)`       | حساب به پیمانه 2pi(مانند تابع سینوس);  `0 <= mod2pi(x) < 2pi`                                                      |
| `divrem(x,y)`     | مقدار `(div(x,y),rem(x,y))` را بر می‌گرداند                                                                             |
| `fldmod(x,y)`     | مقدار `(fld(x,y),mod(x,y))` را بر می‌گرداند                                                                            |
| `gcd(x,y...)`     | بزرگترین مقسوم‌علیه مشترک `x`, `y`, ... را بر می‌گرداند                                              |
| `lcm(x,y...)`     | کوچکترین مضرب مشترک `x`, `y`,... را بر می‌گرداند                                                              |

### توابع علامت و قدرمطلق

| تابع                | توضیحات                                                |
|:----------------------- |:---------------------------------------------------------- |
| `abs(x)`        | یک مقدار مثبت با اندازه‌ی `x`                |
| `abs2(x)`       | توان دوم اندازه‌ی `x`                               |
| `sign(x)`       | علامت `x` را نشان می‌دهد؛ 1+، 0 یا 1- را برمی‌گرداند          |
| `signbit(x)`    | نشان می‌دهد که آیا بیتِ علامت روشن(true) یا خاموش(false) است |
| `copysign(x,y)` | یک مقدار با اندازه `x` و با علامت `y` را برمی‌گرداند      |
| `flipsign(x,y)` | یک مقدار با اندازه `x` و با علامت `x*y` را برمی‌گرداند    |

### توان‌ها، لگاریتم‌ها و ریشه‌ها

| تابع                 | توضیحات                                                                |
|:------------------------ |:-------------------------------------------------------------------------- |
| `sqrt(x)`, `√x`  | ریشه‌ی دوم `x`                                               |
| `cbrt(x)`, `∛x`  | ریشه‌ی سوم `x`                                               |
| `hypot(x,y)`     | وتر مثلث قائم الزاویه‌ای را می‌دهد که اضلاع دیگر آن `y` و `x` هستند(اگر بیش از دو آرگومان به آن بدهید، ریشه دوم مجموع مربعات آرگومان‌ها `x_i^2∑√` را می‌دهد) |
| `exp(x)`         | تابع `e^x`                                        |
| `expm1(x)`       | مقدار دقیق `exp(x)-1` برای `x` نزدیک به صفر                                      |
| `ldexp(x,n)`     | مقدار `x*2^n` را برای `n`‌های صحیح محاسبه می‌کند                     |
| `log(x)`         | لگاریتم طبیعی(بر مبنای عدد نپر) را برای `x` می‌دهد                                                   |
| `log(b,x)`       | لگاریتم `x` بر مبنای `b`                                   |
| `log2(x)`        | لگاریتم `x` بر مبنای `2`                                                    |
| `log10(x)`       | لگاریتم `x` بر مبنای `10`                                  |
| `log1p(x)`       | به دقت `log(1+x)` را برای `x`های نزدیک به صفر حساب می‌کند                                      |
| `exponent(x)`    | توان باینری `x`                                                     |
| `significand(x)` | مانتیس عدد اعشاری `x`       |

برای اینکه بدانید توابعی مانند `hypot`، `expm1` و `log1p` چرا ضروری هستند و به چه کاری می‌آیند، به لینک‌های [expm1, log1p, erfc](https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/), and [hypot](https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/) مراجعه کنید.

### توابع مثلثاتی و هایپربولیک

تمامی توابع استاندارد مثلثاتی و هایپربولیک در جولیا تعریف شده‌اند:

```
sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc
```


تمامی این توابع، تک آرگومانی هستند، که البته `atan` می‌تواند دو آرگومان را متناظر با تابع 
[`atan2`](https://en.wikipedia.org/wiki/Atan2) بپذیرد.

علاوه بر این‌ها، `sinpi(x)` و `cospi(x)` به ترتیب دقت بیشتری را برای محاسبه `sin(pi*x)` و `cos(pi*x)` فراهم می‌کنند.

به منظور محاسبه توابع مثلثاتی با درجه به جای رادیان، تابع را با پسوند `d` بیان کنید. برای مثال `sind(x)` سینوس `x` را محاسبه می‌کند که `x` برحسب درجه بیان شده است. لیست کامل توابع مثلثاتی با دریافت آرگومان درجه‌ای را در زیر مشاهده می‌کنید:

```
sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd
```


### توابع خاص

بسیاری توابع خاص ریاضیاتی دیگر در  پکیج [SpecialFunctions.jl](https://github.com/JuliaMath/SpecialFunctions.jl)
 فراهم شده‌اند.
